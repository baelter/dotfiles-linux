#!/bin/bash

# don't put duplicate lines or lines starting with space in the  history.
# See bash(1) for more options
HISTCONTROL=ignoreboth
HISTFILE=~/.zsh_history
HISTSIZE=999999999
SAVEHIST=$HISTSIZE

export EDITOR=vim
export BUNDLER_EDITOR=code

# Go
# export PATH=$PATH:/usr/local/go/bin
# export GOPATH=$HOME/84codes/go
# export PATH=$PATH:$GOPATH/bin
# ulimit -n 65536

# Ruby
export PATH="$PATH:$HOME/.rbenv/plugins/ruby-build/bin"
# eval "$(rbenv init -)" # done in .zprofile
# export PATH="/usr/local/bin/rubocop-daemon-wrapper:$PATH"
alias rake='noglob rake'

# User bin
export PATH=$HOME/84codes/tools/main/bin:$PATH

# Git
gho() {
  gh repo view --web
}
gwtadd() {
  git fetch
  local branch_name="$1"
  local dir_name="${branch_name##*/}"  # Extract last part after last slash

  if git rev-parse --verify "$branch_name" >/dev/null 2>&1; then
    # Branch exists locally, just create worktree
    git worktree add "$dir_name" "$branch_name"
  elif git rev-parse --verify "origin/$branch_name" >/dev/null 2>&1; then
    # Branch exists on remote, create from origin
    git worktree add -b "$branch_name" "$dir_name" "origin/$branch_name"
  else
    # Branch doesn't exist anywhere, create new branch from HEAD
    git worktree add -b "$branch_name" "$dir_name"
  fi
}

# Tab completion for gwtadd
if [ -n "$BASH_VERSION" ]; then
  # Bash completion
  _gwtadd_complete() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local branches=$(git branch -r 2>/dev/null | grep -v HEAD | sed 's|origin/||' | sed 's/^[[:space:]]*//')
    COMPREPLY=( $(compgen -W "$branches" -- "$cur") )
  }
  complete -F _gwtadd_complete gwtadd
elif [ -n "$ZSH_VERSION" ]; then
  # Zsh completion
  _gwtadd() {
    local branches=(${(f)"$(git branch -r 2>/dev/null | grep -v HEAD | sed 's|origin/||' | sed 's/^[[:space:]]*//')"})
    _describe 'remote branch' branches
  }
  compdef _gwtadd gwtadd
fi

# terminal
export PROMPT_COMMAND='echo -ne "\033]0;${PWD##*/}\007"'
precmd() {
 # sets the tab title to current dir
 echo -ne "\e]1;${PWD##*/}\a"
}

# Locale
export LANG="en_US.UTF-8"
export LC_COLLATE="en_US.UTF-8"
export LC_CTYPE="en_US.UTF-8"
export LC_MESSAGES="en_US.UTF-8"
export LC_MONETARY="en_US.UTF-8"
export LC_NUMERIC="en_US.UTF-8"
export LC_TIME="en_US.UTF-8"
export LC_ALL="en_US.UTF-8"

# Work
hkpsql() {
  psql $(heroku config:get DATABASE_URL) "$@";
}
devpsql() {
  psql $(grep '^DATABASE_URL' .env | awk -F= '{print $2}' | sed "s/'//g" | head -n1) "$@";
}
testport4() {
  nc -4vz $*
}
testport6() {
  nc -6vz $*
}
testssl4() {
  openssl s_client -showcerts -4 -connect $* </dev/null
}
testssl6() {
  openssl s_client -showcerts -6 -connect $* </dev/null
}
kill-rubies() {
  pkill -f 'ruby:'; pkill -f puma
}
csvgrep() { head -n 1 "$1" > "$3"; tail -n +2 "$1" | grep "$2" >> "$3"; }

# Python
if command -v pyenv &> /dev/null
then
  eval "$(pyenv virtualenv-init -)"
  export PATH="$PATH:$HOME/.pyenv/bin"
fi

# Node
NPM_PACKAGES="${HOME}/.npm-global"
export PATH="$PATH:$NPM_PACKAGES/bin"

# Preserve MANPATH if you already defined it somewhere in your config.
# Otherwise, fall back to `manpath` so we can inherit from `/etc/manpath`.
export MANPATH="${MANPATH-$(manpath)}:$NPM_PACKAGES/share/man"

# export SIGN_SSH_KEY_RESET_AGENT=true

export XDG_DATA_DIRS="$XDG_DATA_DIRS:/var/lib/flatpak/exports/share:/home/anders/.local/share/flatpak/exports/share"

if [ -d "$HOME/.cargo/env" ]; then
  . "$HOME/.cargo/env"
fi

export OPENCV_LOG_LEVEL=OFF
export GST_DEBUG=0

# Pipe to clipboard
alias xclip="xclip -selection c"

# Custom lsgit function
function lsgit() {
  local check_status=true

  # Parse arguments
  for arg in "$@"; do
    case "$arg" in
      --no-status)
        check_status=false
        ;;
      --no-color)
        no_color=true
        ;;
    esac
  done

  # Define colors for output
  local DIR_COLOR="\033[1;34m"      # Blue for directory names
  local BRANCH_COLOR="\033[0;31m"   # Red for branch names
  local DIRTY_COLOR=" \033[0;33m"   # Yellow for the dirty symbol
  local BARE_COLOR="\033[0;35m"     # Magenta for bare repos
  local RESET_COLOR="\033[0m"       # Reset color

  # if --no-color is passed, disable colors
  if [[ "$no_color" == "true" ]]; then
    DIR_COLOR=""
    BRANCH_COLOR=""
    DIRTY_COLOR=""
    BARE_COLOR=""
    RESET_COLOR=""
  fi

  local DIRTY_STATUS="$DIRTY_COLORâœ—$RESET_COLOR"  # Default dirty status symbol

  # Iterate through each directory
  for dir in */; do
    # Check if it's a bare repository (optimized: grep config directly)
    if [[ -f "$dir/config" && -f "$dir/HEAD" && -d "$dir/objects" && -d "$dir/refs" ]]; then
      if grep -q "bare = true" "$dir/config" 2>/dev/null; then
        # It's a bare repo - check for worktrees directory
        if [[ -d "$dir/worktrees" ]]; then
          local worktree_count=$(ls "$dir/worktrees" 2>/dev/null | wc -l)
          if [[ $worktree_count -gt 0 ]]; then
            echo -e "${DIR_COLOR}${dir}${RESET_COLOR} ${BARE_COLOR}(${worktree_count} worktrees)${RESET_COLOR}"
          else
            echo -e "${DIR_COLOR}${dir}${RESET_COLOR} ${BARE_COLOR}(bare)${RESET_COLOR}"
          fi
        else
          echo -e "${DIR_COLOR}${dir}${RESET_COLOR} ${BARE_COLOR}(bare)${RESET_COLOR}"
        fi
        continue
      fi
    fi

    # Check if it's a regular git repo or worktree
    if [[ -d "$dir/.git" || -f "$dir/.git" ]]; then
      # Get branch name
      local branch git_status=""
      branch=$(git -C "$dir" rev-parse --abbrev-ref HEAD 2>/dev/null)

      # Check for uncommitted changes unless --no-status flag is passed
      if [[ "$check_status" == "true" ]]; then
        # Use faster diff-index for checking dirty state
        if ! git -C "$dir" diff-index --quiet HEAD -- 2>/dev/null || \
           [[ -n $(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null) ]]; then
          git_status="$DIRTY_STATUS"
        fi
      fi

      echo -e "${DIR_COLOR}${dir}${RESET_COLOR} git:(${BRANCH_COLOR}${branch}${RESET_COLOR})${git_status}"
    else
      # Not a Git repository
      echo "$dir"
    fi
  done
}

# Pretty less
alias less=~/.local/bin/pretty-less.sh
export GOOGLE_CLOUD_PROJECT="copilot-cli"

# Fly.io
export FLYCTL_INSTALL="/home/anders/.fly"
export PATH="$FLYCTL_INSTALL/bin:$PATH"

if [ -n "$VSCODE_AI_TERMINAL" ]; then
  # This block will only execute in a terminal launched by an AI assistant in VS Code
  export PAGER=cat
fi
